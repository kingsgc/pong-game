<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pro Vertical Pong</title>
<style>
  * { box-sizing: border-box; }
  body, html {
    margin: 0; height: 100%; overflow: hidden;
    background: radial-gradient(circle at center, #111, #000);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: white;
    user-select: none;
  }
  canvas {
    display: block; margin: 18px;
    background: linear-gradient(180deg, #222, #000);
    box-shadow: 0 0 30px #0f0;
    border-radius: 12px;
  }
  .scoreboard {
    position: absolute;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 40px;
    font-size: 1.8rem;
    background: rgba(0, 0, 0, 0.5);
    padding: 12px 30px;
    border-radius: 15px;
    border: 2px solid #0f0;
    font-weight: 700;
    z-index: 10;
    letter-spacing: 1.5px;
  }
  .scoreboard span {
    color: #0f0;
  }
  #instructions {
    position: fixed;
    bottom: 20px;
    width: 100%;
    text-align: center;
    font-size: 1rem;
    color: #aaa;
    font-style: italic;
  }
  #pauseOverlay {
    position: fixed;
    top:0; left:0; right:0; bottom:0;
    background: rgba(0,0,0,0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 2.5rem;
    color: #0f0;
    font-weight: 700;
    user-select: none;
    cursor: pointer;
    z-index: 20;
    display: none;
  }
  @media (max-width: 600px) {
    .scoreboard {
      font-size: 1.2rem;
      gap: 20px;
      padding: 8px 16px;
    }
  }
</style>
</head>
<body>

<div class="scoreboard">
  <div>AI: <span id="aiScore">0</span></div>
  <div>You: <span id="playerScore">0</span></div>
</div>

<canvas id="pong"></canvas>

<div id="instructions">
  Move your paddle horizontally near the bottom. First to 10 points wins! Click to pause/resume.
</div>

<div id="pauseOverlay">PAUSED<br>(Click to Resume)</div>

<script>
(() => {
  const canvas = document.getElementById('pong');
  const ctx = canvas.getContext('2d');
  const aiScoreDisplay = document.getElementById('aiScore');
  const playerScoreDisplay = document.getElementById('playerScore');
  const pauseOverlay = document.getElementById('pauseOverlay');
  let paused = false;

  // Responsive canvas setup with aspect ratio 2:3 (width:height)
  function resizeCanvas() {
    const width = window.innerWidth;
    const height = window.innerHeight;
    const aspect = 2 / 3;
    if (width / height > aspect) {
      canvas.height = height * 0.95;
      canvas.width = canvas.height * aspect;
    } else {
      canvas.width = width * 0.95;
      canvas.height = canvas.width / aspect;
    }
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Game constants
  const paddleWidth = canvas.width * 0.25;
  const paddleHeight = canvas.height * 0.025;
  const ballRadius = canvas.width * 0.02;
  const maxScore = 10;

  // Game state
  const player = {
    x: canvas.width / 2 - paddleWidth / 2,
    y: canvas.height - paddleHeight - 15,
    width: paddleWidth,
    height: paddleHeight,
    color: '#0f0',
    score: 0,
    targetX: null, // for smooth paddle movement
  };

  const ai = {
    x: canvas.width / 2 - paddleWidth / 2,
    y: 15,
    width: paddleWidth,
    height: paddleHeight,
    color: '#f00',
    score: 0,
  };

  const ball = {
    x: canvas.width / 2,
    y: canvas.height / 2,
    radius: ballRadius,
    speed: canvas.height * 0.008,
    velocityX: (Math.random() < 0.5 ? -1 : 1) * canvas.width * 0.004,
    velocityY: (Math.random() < 0.5 ? -1 : 1) * canvas.height * 0.006,
    color: '#fff',
  };

  // Particle system for hits
  const particles = [];

  function createParticles(x, y, color) {
    for (let i = 0; i < 10; i++) {
      particles.push({
        x,
        y,
        radius: Math.random() * 2 + 1,
        color,
        speedX: (Math.random() - 0.5) * 4,
        speedY: (Math.random() - 0.5) * 4,
        life: 30,
      });
    }
  }

  // Sounds
  const sounds = {
    hit: new Audio('https://actions.google.com/sounds/v1/impacts/clack.ogg'),
    score: new Audio('https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg')
  };

  function playSound(sound) {
    if (!paused) {
      sounds[sound].currentTime = 0;
      sounds[sound].play();
    }
  }

  // Draw helpers
  function drawRect(x, y, w, h, color) {
    const grad = ctx.createLinearGradient(x, y, x + w, y + h);
    grad.addColorStop(0, color);
    grad.addColorStop(1, '#000');
    ctx.fillStyle = grad;
    ctx.shadowColor = color;
    ctx.shadowBlur = 8;
    ctx.fillRect(x, y, w, h);
    ctx.shadowBlur = 0;
  }

  function drawCircle(x, y, r, color) {
    const grad = ctx.createRadialGradient(x, y, r / 2, x, y, r);
    grad.addColorStop(0, '#fff');
    grad.addColorStop(1, color);
    ctx.fillStyle = grad;
    ctx.shadowColor = color;
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  function drawText(text, x, y, size, color = '#0f0', align = 'center') {
    ctx.fillStyle = color;
    ctx.font = `${size}px 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif`;
    ctx.textAlign = align;
    ctx.fillText(text, x, y);
  }

  // Reset ball to center and randomize velocity
  function resetBall() {
    ball.x = canvas.width / 2;
    ball.y = canvas.height / 2;
    ball.speed = canvas.height * 0.008;
    // Start towards the player who just scored
    ball.velocityY = (Math.random() < 0.5 ? -1 : 1) * ball.speed;
    ball.velocityX = (Math.random() * 2 - 1) * ball.speed * 0.75;
  }

  // Collision detection between ball and paddle
  function collision(b, p) {
    return b.x + b.radius > p.x &&
           b.x - b.radius < p.x + p.width &&
           b.y + b.radius > p.y &&
           b.y - b.radius < p.y + p.height;
  }

  // Update game state
  function update() {
    if (paused) return;

    // Move ball
    ball.x += ball.velocityX;
    ball.y += ball.velocityY;

    // Ball collision with left/right walls
    if (ball.x + ball.radius > canvas.width) {
      ball.x = canvas.width - ball.radius;
      ball.velocityX = -ball.velocityX;
      playSound('hit');
    } else if (ball.x - ball.radius < 0) {
      ball.x = ball.radius;
      ball.velocityX = -ball.velocityX;
      playSound('hit');
    }

    // Player paddle smooth movement easing
    if (player.targetX !== null) {
      const diff = player.targetX - player.x;
      player.x += diff * 0.15;
      // Clamp inside canvas
      if (player.x < 0) player.x = 0;
      if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
    }

    // Ball collision with paddles
    if (collision(ball, player)) {
      ball.y = player.y - ball.radius;
      ball.velocityY = -ball.speed;

      // Change X velocity based on hit position (for angle)
      let hitPos = (ball.x - (player.x + player.width / 2)) / (player.width / 2);
      ball.velocityX = ball.speed * hitPos;

      playSound('hit');
      createParticles(ball.x, ball.y, player.color);

      // Increase speed slightly each hit for challenge
      ball.speed *= 1.05;
      ball.velocityY = -ball.speed;
    } else if (collision(ball, ai)) {
      ball.y = ai.y + ai.height + ball.radius;
      ball.velocityY = ball.speed;

      let hitPos = (ball.x - (ai.x + ai.width / 2)) / (ai.width / 2);
      ball.velocityX = ball.speed * hitPos;

      playSound('hit');
      createParticles(ball.x, ball.y, ai.color);

      ball.speed *= 1.05;
      ball.velocityY = ball.speed;
    }

    // Score update and reset
    if (ball.y - ball.radius < 0) {
      // Player scores
      player.score++;
      playerScoreDisplay.textContent = player.score;
      playSound('score');
      resetBall();
      increaseDifficulty();
    } else if (ball.y + ball.radius > canvas.height) {
      // AI scores
      ai.score++;
      aiScoreDisplay.textContent = ai.score;
      playSound('score');
      resetBall();
      increaseDifficulty();
    }

    // AI paddle movement with dynamic difficulty
    const difficulty = aiDifficulty();
    const target = ball.x - ai.width / 2;
    ai.x += (target - ai.x) * difficulty;

    // Clamp AI paddle inside canvas
    if (ai.x < 0) ai.x = 0;
    if (ai.x + ai.width > canvas.width) ai.x = canvas.width - ai.width;

    // Update particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.speedX;
      p.y += p.speedY;
      p.life--;
      p.radius *= 0.95;
      if (p.life <= 0 || p.radius < 0.1) particles.splice(i, 1);
    }

    checkWin();
  }

  // Increase difficulty by speeding up AI as scores go higher
  function increaseDifficulty() {
    // Nothing complex here, AI speed changes by score in aiDifficulty()
  }

  // AI difficulty as fraction for interpolation (0 to 1)
  function aiDifficulty() {
    // Starts easy, gets harder the more the AI is behind
    const diff = player.score - ai.score;
    if (diff >= 3) return 0.25; // easier if player far ahead
    if (diff <= -3) return 0.39; // harder if AI far ahead
    return 0.25 + diff * 0.17; // balanced in middle
  }

  // Draw everything
  function render() {
    // Background
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Center dashed line
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
    ctx.lineWidth = 3;
    ctx.setLineDash([15, 20]);
    ctx.beginPath();
    ctx.moveTo(0, canvas.height / 2);
    ctx.lineTo(canvas.width, canvas.height / 2);
    ctx.stroke();
    ctx.setLineDash([]);

    // Paddles and ball
    drawRect(player.x, player.y, player.width, player.height, player.color);
    drawRect(ai.x, ai.y, ai.width, ai.height, ai.color);
    drawCircle(ball.x, ball.y, ball.radius, ball.color);

    // Draw particles
    particles.forEach(p => {
      ctx.globalAlpha = p.life / 30;
      drawCircle(p.x, p.y, p.radius, p.color);
      ctx.globalAlpha = 1;
    });
  }

  // Game loop
  function gameLoop() {
    update();
    render();
  }

  // Paddle movement for player: mouse and touch
  function movePaddle(x) {
    const rect = canvas.getBoundingClientRect();
    let posX = x - rect.left - player.width / 2;

    // Clamp
    if (posX < 0) posX = 0;
    if (posX + player.width > canvas.width) posX = canvas.width - player.width;

    // Set target for smooth easing
    player.targetX = posX;
  }

  canvas.addEventListener('mousemove', e => movePaddle(e.clientX));
  canvas.addEventListener('touchmove', e => {
    movePaddle(e.touches[0].clientX);
    e.preventDefault();
  }, { passive: false });

  // Pause/Resume toggle
  function togglePause() {
    paused = !paused;
    pauseOverlay.style.display = paused ? 'flex' : 'none';
  }
  window.addEventListener('click', togglePause);

  // Win detection
  function checkWin() {
    if (player.score >= maxScore) {
      alert('You win! Congrats!');
      resetGame();
    } else if (ai.score >= maxScore) {
      alert('AI wins! Try again.');
      resetGame();
    }
  }

  function resetGame() {
    player.score = 0;
    ai.score = 0;
    playerScoreDisplay.textContent = 0;
    aiScoreDisplay.textContent = 0;
    resetBall();
  }

  resetBall();
  setInterval(gameLoop, 1000 / 60);
})();
</script>

</body>
</html>l>